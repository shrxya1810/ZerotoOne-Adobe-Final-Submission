
"""
Text-to-Speech service with Azure provider only.
"""
import logging
import os
import io
from typing import Optional, Dict, Any, List
from enum import Enum
import asyncio

from ..settings import settings

logger = logging.getLogger(__name__)


class TTSProvider(Enum):
    AZURE = "azure"


class TTSService:
    """
    Text-to-Speech service with Azure provider only.
    """
    
    def __init__(self):
        self.provider = TTSProvider.AZURE
    
    async def generate_speech(self, text: str, voice: str = "en-US-JennyNeural", provider: str = None) -> Dict[str, Any]:
        """
        Generate speech from text using Azure TTS.
        
        Args:
            text: Text to convert to speech
            voice: Voice to use
            provider: TTS provider (ignored, always uses Azure)
            
        Returns:
            Dictionary with success status, file path, duration, and error info
        """
        try:
            # Generate audio data using Azure TTS
            logger.info(f"Starting TTS synthesis with Azure provider")
            audio_data = await self._synthesize_azure(text, voice)
            logger.info(f"TTS synthesis completed, audio data length: {len(audio_data) if audio_data else 0} bytes")
            
            if not audio_data:
                raise RuntimeError("No audio data generated by TTS service")
            
            # Save to temporary file
            import tempfile
            import os
            from datetime import datetime
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            # Ensure temp directory exists
            os.makedirs(settings.TEMP_DIR, exist_ok=True)
            
            # Use wav extension for all providers
            file_ext = "wav"
            temp_file = os.path.join(settings.TEMP_DIR, f"podcast_{timestamp}.{file_ext}")
            
            # Write audio data to file
            logger.info(f"Writing {len(audio_data)} bytes to file: {temp_file}")
            with open(temp_file, 'wb') as f:
                f.write(audio_data)
            
            # Verify file was written
            file_size = os.path.getsize(temp_file)
            logger.info(f"File written successfully, size: {file_size} bytes")
            
            # Estimate duration (rough calculation)
            word_count = len(text.split())
            estimated_seconds = word_count * 0.6  # ~100 words per minute
            duration_minutes = int(estimated_seconds // 60)
            duration_seconds = int(estimated_seconds % 60)
            duration = f"{duration_minutes}:{duration_seconds:02d}"
            
            return {
                "success": True,
                "file_path": temp_file,
                "duration": duration,
                "provider": "azure",
                "voice": voice
            }
            
        except Exception as e:
            logger.error(f"Speech generation failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "file_path": None,
                "duration": "0:00"
            }
    
    async def _synthesize_azure(self, text: str, voice_id: str = None) -> bytes:
        """Synthesize using Azure Speech Services and return audio bytes (in-memory, no default speaker). Handles Azure's 5000 character limit."""
        import azure.cognitiveservices.speech as speechsdk
        logger.info(f"Azure TTS synthesis - Text length: {len(text)}, Voice: {voice_id}")
        logger.info(f"Azure credentials - Key exists: {bool(settings.AZURE_SPEECH_KEY)}, Region: {settings.AZURE_SPEECH_REGION}")
        # Use new variable names with fallback to legacy ones
        azure_key = settings.AZURE_TTS_KEY or settings.AZURE_SPEECH_KEY
        azure_region = settings.AZURE_SPEECH_REGION or "eastus"  # Default region
        
        # Log configuration for debugging
        logger.info(f"Azure TTS config - Key: {'***' if azure_key else 'None'}, Region: {azure_region}, Endpoint: {settings.AZURE_TTS_ENDPOINT}")
        
        if not azure_key:
            raise ValueError("Azure TTS key is required but not provided")
        
        speech_config = speechsdk.SpeechConfig(
            subscription=azure_key,
            region=azure_region
        )
        
        # Set custom endpoint if provided (use endpoint, not endpoint_id)
        import os
        azure_endpoint = os.getenv('AZURE_TTS_ENDPOINT')
        if azure_endpoint and azure_endpoint.strip():
            logger.info(f"Setting custom endpoint: {azure_endpoint}")
            speech_config.endpoint = azure_endpoint
        speech_config.speech_synthesis_language = "en-US"
        speech_config.speech_synthesis_voice_name = voice_id or "en-US-JennyNeural"
        speech_config.set_speech_synthesis_output_format(
            speechsdk.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm
        )
        # Azure TTS limit: 5000 characters per request (SSML/text)
        max_chunk_size = 5000
        text_chunks = [text[i:i+max_chunk_size] for i in range(0, len(text), max_chunk_size)]
        audio_bytes = b""
        for idx, chunk in enumerate(text_chunks):
            logger.info(f"Synthesizing chunk {idx+1}/{len(text_chunks)} (length: {len(chunk)})")
            synthesizer = speechsdk.SpeechSynthesizer(
                speech_config=speech_config,
                audio_config=None
            )
            try:
                if voice_id:
                    ssml = f'''<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xml:lang=\"en-US\">\n<voice name=\"{voice_id}\">{chunk}</voice>\n</speak>'''
                    logger.info(f"Using SSML synthesis with voice: {voice_id}")
                    result = await asyncio.get_event_loop().run_in_executor(
                        None, synthesizer.speak_ssml, ssml
                    )
                else:
                    logger.info("Using plain text synthesis")
                    result = await asyncio.get_event_loop().run_in_executor(
                        None, synthesizer.speak_text, chunk
                    )
                logger.info(f"Azure TTS synthesis call completed, result reason: {result.reason}")
                if result.reason == speechsdk.ResultReason.SynthesizingAudioCompleted:
                    audio_length = len(result.audio_data) if result.audio_data else 0
                    logger.info(f"Azure TTS synthesis successful, audio data length: {audio_length} bytes")
                    if audio_length == 0:
                        logger.error("Audio data is empty despite successful synthesis!")
                    audio_bytes += result.audio_data or b""
                elif result.reason == speechsdk.ResultReason.Canceled:
                    cancellation_details = speechsdk.CancellationDetails(result)
                    logger.error(f"Azure TTS synthesis was canceled: {cancellation_details.reason}")
                    logger.error(f"Cancellation error code: {cancellation_details.error_code}")
                    logger.error(f"Cancellation error details: {cancellation_details.error_details}")
                    
                    # Log additional debugging info
                    logger.error(f"Azure TTS configuration used:")
                    logger.error(f"  - Region: {self.azure_region}")
                    logger.error(f"  - Endpoint: {self.azure_endpoint}")
                    logger.error(f"  - Key set: {'Yes' if self.azure_key else 'No'}")
                    logger.error(f"  - Voice: {voice}")
                    logger.error(f"  - Text length: {len(text)}")
                    
                    raise RuntimeError(f"Azure TTS canceled: {cancellation_details.reason} - {cancellation_details.error_details}")
                else:
                    logger.error(f"Azure TTS synthesis failed: {result.reason}")
                    if hasattr(result, 'error_details'):
                        logger.error(f"Error details: {result.error_details}")
                    raise RuntimeError(f"Azure TTS failed: {result.reason}")
            except Exception as e:
                logger.error(f"Exception during Azure TTS synthesis (chunk {idx+1}): {e}")
                raise
        return audio_bytes


# Global TTS service instance
tts_service = TTSService()


# Convenience functions
async def synthesize_text(text: str, voice_id: Optional[str] = None) -> bytes:
    """Synthesize text using the global TTS service."""
    return await tts_service.synthesize_text(text, voice_id)


def get_available_voices() -> List[Dict[str, Any]]:
    """Get available voices."""
    return tts_service.get_available_voices()


def get_tts_provider() -> str:
    """Get current TTS provider."""
    return tts_service.get_provider()
